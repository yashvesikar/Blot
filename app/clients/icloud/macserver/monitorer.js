const path = require("path");
const readline = require("readline");
const Bottleneck = require("bottleneck");
const exec = require("./exec");
const { iCloudDriveDirectory } = require("./config");
const { spawn } = require("child_process");

const MAX_DEPTH = 1000;

const limiter = new Bottleneck({
  maxConcurrent: 5,
});

// The purpose of this module is to keep iCloud Drive in sync
// and it achieves this by running `brctl monitor` to detect blog
// folders with changes and then it recursively lists their contents
// in order to force iCloud to sync the contents of the folder. It seems
// like using ls as opposed to readdir actually forces iCloud drive to
// push the names of new files and folders to the local system.

// If eventually we run into scaling issues with chokidar we could potentially
// use the information generated by this module to trigger syncs...
const recursiveListLimited = limiter.wrap(async function recursiveList(
  dirPath,
  depth = 0
) {
  if (depth > MAX_DEPTH) {
    console.warn(`Maximum depth ${MAX_DEPTH} reached at ${dirPath}`);
    return;
  }

  console.log(`MONITORER: listing path: ${dirPath} (depth: ${depth})`);

  try {
    const { stdout, stderr } = await exec("ls", ["-la1F", dirPath]);

    if (stderr) {
      throw new Error(`Error listing directory ${dirPath}: ${stderr}`);
    }

    const dirs = stdout
      .split("\n")
      .filter((line) => line.endsWith("/")) // Only dirs end with /
      .map((line) => line.slice(0, -1)) // Remove trailing /
      .filter((name) => name !== "." && name !== "..") // Skip . and ..
      .map((name) => path.join(dirPath, name)); // Full path

    await Promise.all(dirs.map((subdir) => recursiveList(subdir, depth + 1)));
  } catch (error) {
    console.error(
      "Error processing directory",
      dirPath,
      "depth=" + depth,
      error
    );
  }
});


module.exports = () => {
  function startMonitor() {
    const monitorProcess = spawn("brctl", ["monitor", iCloudDriveDirectory]);

    const rl = readline.createInterface({
      input: monitorProcess.stdout,
      crlfDelay: Infinity,
    });

    rl.on("line", (line) => {
      const match = line.match(/blog_[a-fA-F0-9]+/);
      if (match) {
        const blogId = match[0];
        console.log("Detected blog ID:", blogId);
        recursiveListLimited(`${iCloudDriveDirectory}/${blogId}`, 0).catch(
          (error) => {
            console.error(
              `Failed to recursively list contents of ${blogId}:`,
              error
            );
          }
        );
      }
    });

    monitorProcess.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });

    monitorProcess.on("close", (code) => {
      rl.close();
      console.warn(
        `brctl monitor exited with code ${code}, restarting in 1s...`
      );
      setTimeout(startMonitor, 1000);
    });
  }

  startMonitor();
};